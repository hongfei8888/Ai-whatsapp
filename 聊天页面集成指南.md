# 聊天页面全面优化集成指南

## 概述

本指南说明如何将所有新创建的组件和功能集成到现有的聊天页面 `web/app/chat/[id]/page.tsx` 中。

---

## 一、导入新组件

在文件顶部添加所有新组件的导入：

```typescript
// 原有导入保持不变
import { useState, useEffect, useRef, useCallback } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { api } from '@/lib/api';
import WhatsAppLayout, { WhatsAppColors } from '@/components/layout/WhatsAppLayout';
import Sidebar from '@/components/layout/Sidebar';
import { useWebSocket } from '@/lib/useWebSocket';
import KnowledgeSelector from '@/components/KnowledgeSelector';

// 新增：媒体组件
import MediaPreview from '@/components/media/MediaPreview';
import MediaUploader from '@/components/media/MediaUploader';

// 新增：消息操作组件
import QuotedMessage from '@/components/chat/QuotedMessage';
import MessageContextMenu, { getMessageMenuItems } from '@/components/chat/MessageContextMenu';
import MessageEditor from '@/components/chat/MessageEditor';
import ForwardDialog from '@/components/chat/ForwardDialog';

// 新增：聊天辅助组件
import MessageSearch from '@/components/chat/MessageSearch';
import ThreadLabels from '@/components/chat/ThreadLabels';
```

---

## 二、扩展状态管理

在现有的状态基础上，添加新的状态变量：

```typescript
export default function ChatPage() {
  // ... 现有状态保持不变
  
  // 新增：消息操作相关状态
  const [replyToMessage, setReplyToMessage] = useState<any | null>(null);
  const [editingMessageId, setEditingMessageId] = useState<string | null>(null);
  const [selectedMessages, setSelectedMessages] = useState<Set<string>>(new Set());
  
  // 新增：对话框状态
  const [showForwardDialog, setShowForwardDialog] = useState(false);
  const [forwardMessage, setForwardMessage] = useState<any | null>(null);
  const [showMediaUploader, setShowMediaUploader] = useState(false);
  
  // 新增：UI 状态
  const [showSearch, setShowSearch] = useState(false);
  const [showKnowledgeSelector, setShowKnowledgeSelector] = useState(false); // 已存在
  
  // 新增：右键菜单状态
  const [contextMenu, setContextMenu] = useState<{
    show: boolean;
    x: number;
    y: number;
    message: any;
  } | null>(null);
  
  // 新增：分页加载状态
  const [hasMoreMessages, setHasMoreMessages] = useState(true);
  const [loadingMoreMessages, setLoadingMoreMessages] = useState(false);
  
  // 新增：草稿自动保存
  const draftSaveTimerRef = useRef<NodeJS.Timeout>();
  
  // ... 其他状态保持不变
}
```

---

## 三、新增核心功能

### 3.1 草稿自动保存

添加草稿自动保存的 useEffect：

```typescript
// 草稿自动保存
useEffect(() => {
  if (!threadId || !inputMessage) return;
  
  // 清除之前的定时器
  if (draftSaveTimerRef.current) {
    clearTimeout(draftSaveTimerRef.current);
  }
  
  // 延迟保存草稿（防抖）
  draftSaveTimerRef.current = setTimeout(async () => {
    try {
      await api.threads.saveDraft(threadId, inputMessage);
      console.log('💾 草稿已保存');
    } catch (error) {
      console.error('保存草稿失败:', error);
    }
  }, 1000); // 1秒延迟
  
  return () => {
    if (draftSaveTimerRef.current) {
      clearTimeout(draftSaveTimerRef.current);
    }
  };
}, [inputMessage, threadId]);
```

### 3.2 加载草稿

在 `loadThread` 函数中添加加载草稿的逻辑：

```typescript
const loadThread = async () => {
  // ... 现有代码保持不变
  
  // 新增：加载草稿
  try {
    const draft = await api.threads.getDraft(threadId);
    if (draft?.draft) {
      setInputMessage(draft.draft);
    }
  } catch (error) {
    console.error('加载草稿失败:', error);
  }
  
  // ... 其他代码保持不变
};
```

### 3.3 分页加载历史消息

添加加载更多消息的函数：

```typescript
const loadMoreMessages = async () => {
  if (!threadId || loadingMoreMessages || !hasMoreMessages) return;
  
  try {
    setLoadingMoreMessages(true);
    
    // 获取最早的消息时间
    const oldestMessage = messages[0];
    const before = oldestMessage?.createdAt;
    
    const data = await api.threads.getMessages(threadId, 50, before);
    
    if (data.messages && data.messages.length > 0) {
      // 保存当前滚动位置
      const container = messageContainerRef.current;
      const oldScrollHeight = container?.scrollHeight || 0;
      
      // 添加历史消息到列表顶部
      setMessages((prev) => [...data.messages, ...prev]);
      setHasMoreMessages(data.hasMore || false);
      
      // 恢复滚动位置
      setTimeout(() => {
        if (container) {
          const newScrollHeight = container.scrollHeight;
          container.scrollTop = newScrollHeight - oldScrollHeight;
        }
      }, 0);
    } else {
      setHasMoreMessages(false);
    }
  } catch (error) {
    console.error('加载历史消息失败:', error);
  } finally {
    setLoadingMoreMessages(false);
  }
};

// 监听滚动事件
const handleScroll = useCallback(() => {
  const container = messageContainerRef.current;
  if (!container) return;
  
  // 滚动到顶部时加载更多
  if (container.scrollTop < 100) {
    loadMoreMessages();
  }
}, [loadingMoreMessages, hasMoreMessages]);

// 添加滚动监听
useEffect(() => {
  const container = messageContainerRef.current;
  if (!container) return;
  
  container.addEventListener('scroll', handleScroll);
  return () => container.removeEventListener('scroll', handleScroll);
}, [handleScroll]);
```

### 3.4 消息操作

添加消息操作的处理函数：

```typescript
// 引用消息
const handleReplyMessage = (message: any) => {
  setReplyToMessage(message);
  setContextMenu(null);
  inputRef.current?.focus();
};

// 编辑消息
const handleEditMessage = async (messageId: string, newText: string) => {
  try {
    await api.messages.edit(messageId, newText);
    setEditingMessageId(null);
    console.log('✅ 消息已编辑');
  } catch (error) {
    console.error('编辑消息失败:', error);
    throw error;
  }
};

// 删除消息
const handleDeleteMessage = async (message: any) => {
  if (!confirm('确定要删除这条消息吗？')) return;
  
  try {
    await api.messages.delete(message.id);
    setContextMenu(null);
    console.log('✅ 消息已删除');
  } catch (error) {
    console.error('删除消息失败:', error);
    alert('删除失败，请重试');
  }
};

// 转发消息
const handleForwardMessage = async (threadIds: string[]) => {
  if (!forwardMessage) return;
  
  try {
    await api.messages.forward(forwardMessage.id, threadIds);
    setShowForwardDialog(false);
    setForwardMessage(null);
    setContextMenu(null);
    console.log(`✅ 消息已转发到 ${threadIds.length} 个会话`);
    alert(`消息已转发到 ${threadIds.length} 个会话`);
  } catch (error) {
    console.error('转发消息失败:', error);
    throw error;
  }
};

// 标记星标
const handleStarMessage = async (message: any) => {
  try {
    await api.messages.star(message.id, !message.isStarred);
    setContextMenu(null);
    
    // 更新本地状态
    setMessages((prev) =>
      prev.map((msg) =>
        msg.id === message.id
          ? { ...msg, isStarred: !msg.isStarred }
          : msg
      )
    );
  } catch (error) {
    console.error('标记消息失败:', error);
    alert('操作失败，请重试');
  }
};

// 复制消息
const handleCopyMessage = (message: any) => {
  if (message.text) {
    navigator.clipboard.writeText(message.text);
    alert('已复制到剪贴板');
    setContextMenu(null);
  }
};

// 右键菜单
const handleMessageContextMenu = (e: React.MouseEvent, message: any) => {
  e.preventDefault();
  
  setContextMenu({
    show: true,
    x: e.clientX,
    y: e.clientY,
    message,
  });
};
```

### 3.5 媒体文件上传

添加媒体上传处理：

```typescript
const handleMediaUpload = async (result: any) => {
  if (!threadId) return;
  
  try {
    // 创建包含媒体的消息
    const messageData = {
      threadId,
      text: result.fileName || '',
      mediaUrl: result.url,
      mediaType: result.type,
      mediaMimeType: result.mimeType,
      mediaSize: result.size,
      mediaFileName: result.fileName,
      thumbnailUrl: result.thumbnailUrl,
    };
    
    await api.sendMessage(threadId, '', messageData);
    setShowMediaUploader(false);
    console.log('✅ 媒体文件已发送');
  } catch (error) {
    console.error('发送媒体消息失败:', error);
    alert('发送失败，请重试');
  }
};
```

### 3.6 更新发送消息函数

修改现有的 `handleSendMessage` 函数以支持引用回复：

```typescript
const handleSendMessage = async () => {
  if (!inputMessage.trim() || sending || !threadId) return;
  
  try {
    setSending(true);
    
    // 如果有引用消息，使用引用API
    if (replyToMessage) {
      await api.messages.reply(threadId, inputMessage.trim(), replyToMessage.id);
    } else {
      await api.sendMessage(threadId, inputMessage.trim());
    }
    
    // 清空输入和引用
    setInputMessage('');
    setReplyToMessage(null);
    setSending(false);
    
    // 清除草稿
    api.threads.saveDraft(threadId, '').catch(console.error);
    
    // 聚焦输入框
    inputRef.current?.focus();
  } catch (error: any) {
    console.error('发送消息失败:', error);
    alert('发送失败: ' + error.message);
    setSending(false);
  }
};
```

---

## 四、更新UI渲染

### 4.1 聊天头部添加操作按钮

在聊天头部添加搜索、更多操作按钮：

```typescript
// 在聊天头部（chatHeader）中添加
<div style={styles.chatHeader}>
  {/* 现有的联系人信息 */}
  <div style={{ display: 'flex', alignItems: 'center', gap: '12px', flex: 1 }}>
    {/* ... 头像和名称 */}
  </div>
  
  {/* 新增：操作按钮 */}
  <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
    {/* 搜索按钮 */}
    <button
      onClick={() => setShowSearch(!showSearch)}
      style={{
        width: '40px',
        height: '40px',
        borderRadius: '50%',
        border: 'none',
        backgroundColor: showSearch ? WhatsAppColors.selected : 'transparent',
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        fontSize: '20px',
      }}
      title="搜索消息"
    >
      🔍
    </button>
    
    {/* 更多操作按钮 */}
    <button
      onClick={() => {/* 显示更多菜单 */}}
      style={{
        width: '40px',
        height: '40px',
        borderRadius: '50%',
        border: 'none',
        backgroundColor: 'transparent',
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        fontSize: '20px',
      }}
      title="更多"
    >
      ⋮
    </button>
  </div>
</div>

{/* 搜索组件 */}
{showSearch && (
  <MessageSearch
    threadId={threadId}
    onMessageClick={(messageId) => {
      // TODO: 跳转到指定消息
      console.log('跳转到消息:', messageId);
    }}
    onClose={() => setShowSearch(false)}
  />
)}
```

### 4.2 更新消息渲染

修改消息渲染函数以支持所有新功能：

```typescript
const renderMessage = (message: any, index: number) => {
  const isOwn = message.direction === 'OUT' || message.fromMe;
  const isEditing = editingMessageId === message.id;
  
  return (
    <div
      key={message.id}
      ref={index === messages.length - 1 ? lastMessageRef : null}
      onContextMenu={(e) => handleMessageContextMenu(e, message)}
      style={{
        display: 'flex',
        justifyContent: isOwn ? 'flex-end' : 'flex-start',
        marginBottom: '8px',
        padding: '0 12px',
      }}
    >
      <div
        style={{
          maxWidth: '65%',
          backgroundColor: isOwn ? WhatsAppColors.ownMessage : WhatsAppColors.otherMessage,
          borderRadius: '8px',
          padding: '8px 12px',
          position: 'relative',
        }}
      >
        {/* 引用的消息 */}
        {message.replyTo && (
          <div style={{ marginBottom: '8px' }}>
            <QuotedMessage
              message={message.replyTo}
              onJumpTo={(id) => {
                // TODO: 跳转到消息
                console.log('跳转到:', id);
              }}
              compact
            />
          </div>
        )}
        
        {/* 媒体内容 */}
        {message.mediaUrl && (
          <div style={{ marginBottom: message.text ? '8px' : 0 }}>
            <MediaPreview
              mediaUrl={message.mediaUrl}
              mediaType={message.mediaType}
              mediaMimeType={message.mediaMimeType}
              mediaFileName={message.mediaFileName}
              mediaSize={message.mediaSize}
              thumbnailUrl={message.thumbnailUrl}
              duration={message.duration}
            />
          </div>
        )}
        
        {/* 编辑模式 */}
        {isEditing ? (
          <MessageEditor
            initialText={message.text || ''}
            onSave={(newText) => handleEditMessage(message.id, newText)}
            onCancel={() => setEditingMessageId(null)}
          />
        ) : (
          <>
            {/* 消息文本 */}
            {message.isDeleted ? (
              <div style={{ fontStyle: 'italic', color: '#8696a0' }}>
                此消息已删除
              </div>
            ) : message.text && (
              <div style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-word' }}>
                {message.text}
              </div>
            )}
            
            {/* 翻译文本（如果有） */}
            {message.translatedText && !message.isDeleted && (
              <div
                style={{
                  marginTop: '8px',
                  paddingTop: '8px',
                  borderTop: '1px solid rgba(0,0,0,0.1)',
                  color: '#667781',
                  fontSize: '13px',
                }}
              >
                <div style={{ fontSize: '11px', marginBottom: '4px' }}>🌐 翻译:</div>
                {message.translatedText}
              </div>
            )}
            
            {/* 消息元数据 */}
            <div
              style={{
                display: 'flex',
                justifyContent: 'flex-end',
                alignItems: 'center',
                gap: '4px',
                marginTop: '4px',
                fontSize: '11px',
                color: 'rgba(0,0,0,0.45)',
              }}
            >
              {message.isEdited && <span>已编辑</span>}
              {message.isStarred && <span>⭐</span>}
              <span>
                {new Date(message.createdAt).toLocaleTimeString('zh-CN', {
                  hour: '2-digit',
                  minute: '2-digit',
                })}
              </span>
              {isOwn && (
                <span>
                  {message.readAt ? '✓✓' : message.deliveredAt ? '✓✓' : '✓'}
                </span>
              )}
            </div>
          </>
        )}
      </div>
    </div>
  );
};
```

### 4.3 输入区域更新

在输入区域添加引用预览和媒体按钮：

```typescript
<div style={styles.inputContainer}>
  {/* 引用消息预览 */}
  {replyToMessage && (
    <div style={{ padding: '8px 12px', backgroundColor: WhatsAppColors.background }}>
      <QuotedMessage
        message={replyToMessage}
        onCancel={() => setReplyToMessage(null)}
        compact
      />
    </div>
  )}
  
  <div style={styles.inputRow}>
    {/* 附件按钮 */}
    <button
      onClick={() => setShowMediaUploader(true)}
      style={{
        width: '40px',
        height: '40px',
        borderRadius: '50%',
        border: 'none',
        backgroundColor: 'transparent',
        cursor: 'pointer',
        fontSize: '24px',
      }}
      title="附件"
    >
      📎
    </button>
    
    {/* 现有的输入框和其他按钮 */}
    {/* ... */}
  </div>
</div>
```

### 4.4 添加对话框组件

在页面底部添加所有对话框：

```typescript
{/* 右键菜单 */}
{contextMenu?.show && (
  <MessageContextMenu
    x={contextMenu.x}
    y={contextMenu.y}
    items={getMessageMenuItems(contextMenu.message, {
      onReply: () => handleReplyMessage(contextMenu.message),
      onEdit: () => setEditingMessageId(contextMenu.message.id),
      onDelete: () => handleDeleteMessage(contextMenu.message),
      onForward: () => {
        setForwardMessage(contextMenu.message);
        setShowForwardDialog(true);
      },
      onStar: () => handleStarMessage(contextMenu.message),
      onCopy: () => handleCopyMessage(contextMenu.message),
    })}
    onClose={() => setContextMenu(null)}
  />
)}

{/* 转发对话框 */}
{showForwardDialog && forwardMessage && (
  <ForwardDialog
    message={forwardMessage}
    onForward={handleForwardMessage}
    onClose={() => {
      setShowForwardDialog(false);
      setForwardMessage(null);
    }}
  />
)}

{/* 媒体上传器 */}
{showMediaUploader && (
  <div
    style={{
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      zIndex: 9999,
    }}
    onClick={() => setShowMediaUploader(false)}
  >
    <div
      onClick={(e) => e.stopPropagation()}
      style={{
        backgroundColor: WhatsAppColors.panelBackground,
        borderRadius: '12px',
        padding: '24px',
        maxWidth: '500px',
        width: '90%',
      }}
    >
      <h3 style={{ marginBottom: '16px' }}>上传文件</h3>
      <MediaUploader
        onUploadComplete={handleMediaUpload}
        onUploadError={(error) => {
          console.error('上传失败:', error);
          alert('上传失败: ' + error.message);
        }}
      />
      <button
        onClick={() => setShowMediaUploader(false)}
        style={{
          marginTop: '16px',
          padding: '8px 16px',
          width: '100%',
        }}
      >
        取消
      </button>
    </div>
  </div>
)}
```

---

## 五、WebSocket 事件处理增强

在现有的 WebSocket 监听中添加新事件：

```typescript
useEffect(() => {
  if (!lastMessage) return;
  
  const { type, data } = lastMessage;
  
  switch (type) {
    case 'new_message':
      handleNewMessage(data);
      break;
      
    case 'message_edited':
      setMessages((prev) =>
        prev.map((msg) =>
          msg.id === data.messageId
            ? { ...msg, text: data.text, isEdited: true, editedAt: data.editedAt }
            : msg
        )
      );
      break;
      
    case 'message_deleted':
      setMessages((prev) =>
        prev.map((msg) =>
          msg.id === data.messageId
            ? { ...msg, isDeleted: true, deletedAt: data.deletedAt }
            : msg
        )
      );
      break;
      
    case 'message_starred':
      setMessages((prev) =>
        prev.map((msg) =>
          msg.id === data.messageId
            ? { ...msg, isStarred: data.isStarred, starredAt: data.starredAt }
            : msg
        )
      );
      break;
      
    case 'message_status':
      setMessages((prev) =>
        prev.map((msg) =>
          msg.id === data.messageId
            ? {
                ...msg,
                deliveredAt: data.delivered ? new Date().toISOString() : msg.deliveredAt,
                readAt: data.read ? new Date().toISOString() : msg.readAt,
              }
            : msg
        )
      );
      break;
  }
}, [lastMessage]);
```

---

## 六、性能优化

### 6.1 使用 React.memo 包装消息组件

创建一个 memo 化的消息组件：

```typescript
const MessageBubble = React.memo(({ message, isOwn, isEditing, onContextMenu, onEdit, onCancel }: any) => {
  // 渲染逻辑
  return (/* ... */);
});
```

### 6.2 使用 useCallback 包装事件处理函数

确保所有事件处理函数都使用 `useCallback` 包装：

```typescript
const handleReplyMessage = useCallback((message: any) => {
  setReplyToMessage(message);
  setContextMenu(null);
  inputRef.current?.focus();
}, []);

const handleEditMessage = useCallback(async (messageId: string, newText: string) => {
  // ...
}, []);

// ... 其他函数同理
```

---

## 七、实施步骤

### 第 1 步：备份现有文件
```bash
cp web/app/chat/[id]/page.tsx web/app/chat/[id]/page.tsx.backup
```

### 第 2 步：添加导入
在文件顶部添加所有新组件的导入

### 第 3 步：扩展状态
添加所有新的状态变量

### 第 4 步：添加新功能函数
逐个添加消息操作、媒体上传等函数

### 第 5 步：更新UI
更新消息渲染、输入区域、头部等UI

### 第 6 步：添加对话框
在页面底部添加所有对话框组件

### 第 7 步：测试
全面测试所有新功能

---

## 八、测试清单

- [ ] 媒体文件上传和显示
- [ ] 引用消息发送和显示
- [ ] 消息编辑功能
- [ ] 消息删除功能
- [ ] 消息转发功能
- [ ] 消息星标功能
- [ ] 右键菜单显示正确选项
- [ ] 消息搜索功能
- [ ] 历史消息分页加载
- [ ] 草稿自动保存和加载
- [ ] WebSocket 实时更新

---

## 九、常见问题

### Q1：如何跳转到指定消息？
A：可以使用 `scrollIntoView` 或维护一个消息ID到DOM元素的映射。

### Q2：如何处理大量消息的性能问题？
A：使用虚拟滚动（react-window）或消息分页。

### Q3：如何处理媒体文件的加载失败？
A：在 MediaPreview 组件中添加错误处理和重试机制。

---

**完成以上步骤后，聊天页面将具备完整的现代即时通讯功能！**

