# 聊天系统性能优化实施指南

## 概述

本指南提供了一系列性能优化策略，以确保聊天系统在处理大量消息、媒体文件和实时更新时保持流畅。

---

## 一、消息渲染优化

### 1.1 使用 React.memo 减少重渲染

#### 创建 memo 化的消息组件

**文件**: `web/components/chat/MessageBubble.tsx`（新建）

```typescript
'use client';

import React, { memo } from 'react';
import MediaPreview from '../media/MediaPreview';
import QuotedMessage from './QuotedMessage';
import MessageEditor from './MessageEditor';
import { WhatsAppColors } from '@/components/layout/WhatsAppLayout';

interface MessageBubbleProps {
  message: any;
  isOwn: boolean;
  isEditing: boolean;
  onContextMenu: (e: React.MouseEvent) => void;
  onEdit: (messageId: string, newText: string) => Promise<void>;
  onCancelEdit: () => void;
  onJumpToMessage?: (messageId: string) => void;
}

const MessageBubble = memo(({
  message,
  isOwn,
  isEditing,
  onContextMenu,
  onEdit,
  onCancelEdit,
  onJumpToMessage,
}: MessageBubbleProps) => {
  return (
    <div
      onContextMenu={onContextMenu}
      style={{
        maxWidth: '65%',
        backgroundColor: isOwn ? WhatsAppColors.ownMessage : WhatsAppColors.otherMessage,
        borderRadius: '8px',
        padding: '8px 12px',
        position: 'relative',
      }}
    >
      {/* 引用的消息 */}
      {message.replyTo && (
        <div style={{ marginBottom: '8px' }}>
          <QuotedMessage
            message={message.replyTo}
            onJumpTo={onJumpToMessage}
            compact
          />
        </div>
      )}
      
      {/* 媒体内容 */}
      {message.mediaUrl && (
        <div style={{ marginBottom: message.text ? '8px' : 0 }}>
          <MediaPreview
            mediaUrl={message.mediaUrl}
            mediaType={message.mediaType}
            mediaMimeType={message.mediaMimeType}
            mediaFileName={message.mediaFileName}
            mediaSize={message.mediaSize}
            thumbnailUrl={message.thumbnailUrl}
            duration={message.duration}
          />
        </div>
      )}
      
      {/* 编辑模式或消息文本 */}
      {isEditing ? (
        <MessageEditor
          initialText={message.text || ''}
          onSave={(newText) => onEdit(message.id, newText)}
          onCancel={onCancelEdit}
        />
      ) : (
        <>
          {message.isDeleted ? (
            <div style={{ fontStyle: 'italic', color: '#8696a0' }}>
              此消息已删除
            </div>
          ) : message.text && (
            <div style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-word' }}>
              {message.text}
            </div>
          )}
          
          {/* 翻译文本 */}
          {message.translatedText && !message.isDeleted && (
            <div
              style={{
                marginTop: '8px',
                paddingTop: '8px',
                borderTop: '1px solid rgba(0,0,0,0.1)',
                color: '#667781',
                fontSize: '13px',
              }}
            >
              <div style={{ fontSize: '11px', marginBottom: '4px' }}>🌐 翻译:</div>
              {message.translatedText}
            </div>
          )}
          
          {/* 消息元数据 */}
          <div
            style={{
              display: 'flex',
              justifyContent: 'flex-end',
              alignItems: 'center',
              gap: '4px',
              marginTop: '4px',
              fontSize: '11px',
              color: 'rgba(0,0,0,0.45)',
            }}
          >
            {message.isEdited && <span>已编辑</span>}
            {message.isStarred && <span>⭐</span>}
            <span>
              {new Date(message.createdAt).toLocaleTimeString('zh-CN', {
                hour: '2-digit',
                minute: '2-digit',
              })}
            </span>
            {isOwn && (
              <span>
                {message.readAt ? '✓✓' : message.deliveredAt ? '✓✓' : '✓'}
              </span>
            )}
          </div>
        </>
      )}
    </div>
  );
}, (prevProps, nextProps) => {
  // 自定义比较函数
  return (
    prevProps.message.id === nextProps.message.id &&
    prevProps.message.text === nextProps.message.text &&
    prevProps.message.isEdited === nextProps.message.isEdited &&
    prevProps.message.isDeleted === nextProps.message.isDeleted &&
    prevProps.message.isStarred === nextProps.message.isStarred &&
    prevProps.message.translatedText === nextProps.message.translatedText &&
    prevProps.message.deliveredAt === nextProps.message.deliveredAt &&
    prevProps.message.readAt === nextProps.message.readAt &&
    prevProps.isEditing === nextProps.isEditing
  );
});

MessageBubble.displayName = 'MessageBubble';

export default MessageBubble;
```

### 1.2 使用 useCallback 包装事件处理函数

在聊天页面中：

```typescript
const handleEditMessage = useCallback(async (messageId: string, newText: string) => {
  try {
    await api.messages.edit(messageId, newText);
    setEditingMessageId(null);
  } catch (error) {
    console.error('编辑消息失败:', error);
    throw error;
  }
}, []);

const handleCancelEdit = useCallback(() => {
  setEditingMessageId(null);
}, []);

const handleJumpToMessage = useCallback((messageId: string) => {
  // 实现跳转逻辑
  const element = document.getElementById(`message-${messageId}`);
  element?.scrollIntoView({ behavior: 'smooth', block: 'center' });
}, []);
```

### 1.3 消息列表虚拟化（可选，适用于1000+消息）

如果需要处理大量消息，可以使用 `react-window`：

```bash
npm install react-window @types/react-window
```

**文件**: `web/components/chat/VirtualMessageList.tsx`

```typescript
'use client';

import React, { useRef, useEffect } from 'react';
import { FixedSizeList as List } from 'react-window';
import MessageBubble from './MessageBubble';

interface VirtualMessageListProps {
  messages: any[];
  height: number;
  onScroll?: (scrollTop: number) => void;
  editingMessageId: string | null;
  onEdit: (messageId: string, newText: string) => Promise<void>;
  onCancelEdit: () => void;
  onContextMenu: (e: React.MouseEvent, message: any) => void;
}

export default function VirtualMessageList({
  messages,
  height,
  onScroll,
  editingMessageId,
  onEdit,
  onCancelEdit,
  onContextMenu,
}: VirtualMessageListProps) {
  const listRef = useRef<any>(null);
  
  useEffect(() => {
    // 滚动到底部
    if (listRef.current) {
      listRef.current.scrollToItem(messages.length - 1, 'end');
    }
  }, [messages.length]);
  
  const Row = ({ index, style }: any) => {
    const message = messages[index];
    const isOwn = message.direction === 'OUT' || message.fromMe;
    
    return (
      <div style={style}>
        <div
          id={`message-${message.id}`}
          style={{
            display: 'flex',
            justifyContent: isOwn ? 'flex-end' : 'flex-start',
            padding: '4px 12px',
          }}
        >
          <MessageBubble
            message={message}
            isOwn={isOwn}
            isEditing={editingMessageId === message.id}
            onContextMenu={(e) => onContextMenu(e, message)}
            onEdit={onEdit}
            onCancelEdit={onCancelEdit}
          />
        </div>
      </div>
    );
  };
  
  return (
    <List
      ref={listRef}
      height={height}
      itemCount={messages.length}
      itemSize={100} // 估算的消息高度，可以使用 dynamic item size
      width="100%"
      onScroll={({ scrollOffset }) => onScroll?.(scrollOffset)}
    >
      {Row}
    </List>
  );
}
```

---

## 二、图片和媒体优化

### 2.1 图片懒加载

**文件**: `web/components/media/LazyImage.tsx`（新建）

```typescript
'use client';

import React, { useState, useEffect, useRef } from 'react';

interface LazyImageProps {
  src: string;
  alt?: string;
  thumbnail?: string;
  style?: React.CSSProperties;
  onClick?: () => void;
}

export default function LazyImage({ src, alt, thumbnail, style, onClick }: LazyImageProps) {
  const [loaded, setLoaded] = useState(false);
  const [inView, setInView] = useState(false);
  const imgRef = useRef<HTMLDivElement>(null);
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setInView(true);
          observer.disconnect();
        }
      },
      { rootMargin: '50px' } // 提前50px开始加载
    );
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => observer.disconnect();
  }, []);
  
  return (
    <div ref={imgRef} style={{ position: 'relative', ...style }} onClick={onClick}>
      {/* 缩略图或占位符 */}
      {!loaded && (
        <div
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: '#f0f2f5',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}
        >
          {thumbnail ? (
            <img src={thumbnail} alt={alt} style={{ filter: 'blur(10px)', width: '100%', height: '100%' }} />
          ) : (
            <span>加载中...</span>
          )}
        </div>
      )}
      
      {/* 实际图片 */}
      {inView && (
        <img
          src={src}
          alt={alt}
          onLoad={() => setLoaded(true)}
          style={{
            width: '100%',
            display: loaded ? 'block' : 'none',
          }}
        />
      )}
    </div>
  );
}
```

### 2.2 图片压缩（上传前）

在 `MediaUploader` 组件中添加图片压缩：

```typescript
// 安装 browser-image-compression
// npm install browser-image-compression

import imageCompression from 'browser-image-compression';

const compressImage = async (file: File): Promise<File> => {
  const options = {
    maxSizeMB: 1, // 最大1MB
    maxWidthOrHeight: 1920, // 最大宽度或高度
    useWebWorker: true, // 使用Web Worker提升性能
  };
  
  try {
    const compressedFile = await imageCompression(file, options);
    console.log(`压缩前: ${(file.size / 1024 / 1024).toFixed(2)}MB`);
    console.log(`压缩后: ${(compressedFile.size / 1024 / 1024).toFixed(2)}MB`);
    return compressedFile;
  } catch (error) {
    console.error('图片压缩失败:', error);
    return file; // 压缩失败则返回原文件
  }
};

// 在上传前调用
const handleFileSelect = async (files: FileList | null) => {
  if (!files || files.length === 0) return;
  
  let file = files[0];
  
  // 如果是图片，进行压缩
  if (file.type.startsWith('image/')) {
    file = await compressImage(file);
  }
  
  // 继续上传...
};
```

---

## 三、缓存策略

### 3.1 消息列表缓存

使用 `localStorage` 或 `IndexedDB` 缓存消息：

```typescript
// 缓存工具类
class MessageCache {
  private static CACHE_KEY = 'whatsapp_messages_cache';
  private static CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24小时
  
  static save(threadId: string, messages: any[]) {
    try {
      const cache = {
        threadId,
        messages,
        timestamp: Date.now(),
      };
      localStorage.setItem(`${this.CACHE_KEY}_${threadId}`, JSON.stringify(cache));
    } catch (error) {
      console.error('保存缓存失败:', error);
    }
  }
  
  static load(threadId: string): any[] | null {
    try {
      const cached = localStorage.getItem(`${this.CACHE_KEY}_${threadId}`);
      if (!cached) return null;
      
      const cache = JSON.parse(cached);
      
      // 检查是否过期
      if (Date.now() - cache.timestamp > this.CACHE_EXPIRY) {
        this.clear(threadId);
        return null;
      }
      
      return cache.messages;
    } catch (error) {
      console.error('加载缓存失败:', error);
      return null;
    }
  }
  
  static clear(threadId: string) {
    localStorage.removeItem(`${this.CACHE_KEY}_${threadId}`);
  }
  
  static clearAll() {
    const keys = Object.keys(localStorage);
    keys.forEach((key) => {
      if (key.startsWith(this.CACHE_KEY)) {
        localStorage.removeItem(key);
      }
    });
  }
}

// 在聊天页面中使用
const loadThread = async () => {
  // 先尝试从缓存加载
  const cachedMessages = MessageCache.load(threadId);
  if (cachedMessages) {
    setMessages(cachedMessages);
    setLoading(false);
  }
  
  // 然后从服务器加载最新数据
  try {
    const data = await api.getThread(threadId);
    setMessages(data.messages);
    
    // 更新缓存
    MessageCache.save(threadId, data.messages);
  } catch (error) {
    console.error('加载会话失败:', error);
  } finally {
    setLoading(false);
  }
};
```

### 3.2 媒体文件 URL 缓存

```typescript
class MediaUrlCache {
  private static cache = new Map<string, string>();
  
  static set(mediaId: string, url: string) {
    this.cache.set(mediaId, url);
  }
  
  static get(mediaId: string): string | undefined {
    return this.cache.get(mediaId);
  }
  
  static has(mediaId: string): boolean {
    return this.cache.has(mediaId);
  }
  
  static clear() {
    this.cache.clear();
  }
}

// 使用
const getMediaUrl = async (mediaId: string): Promise<string> => {
  // 先检查缓存
  if (MediaUrlCache.has(mediaId)) {
    return MediaUrlCache.get(mediaId)!;
  }
  
  // 从API获取
  const url = await api.media.getUrl(mediaId);
  
  // 缓存URL
  MediaUrlCache.set(mediaId, url);
  
  return url;
};
```

### 3.3 草稿本地存储优化

使用防抖来减少存储操作：

```typescript
import { debounce } from 'lodash-es'; // 或自己实现

const saveDraftDebounced = debounce(async (threadId: string, draft: string) => {
  try {
    await api.threads.saveDraft(threadId, draft);
    console.log('💾 草稿已保存');
  } catch (error) {
    console.error('保存草稿失败:', error);
  }
}, 1000); // 1秒防抖

// 使用
useEffect(() => {
  if (threadId && inputMessage) {
    saveDraftDebounced(threadId, inputMessage);
  }
}, [inputMessage, threadId]);
```

---

## 四、上传优化

### 4.1 大文件分片上传

```typescript
const CHUNK_SIZE = 1024 * 1024; // 1MB per chunk

async function uploadFileInChunks(file: File): Promise<string> {
  const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
  const uploadId = generateUniqueId();
  
  for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
    const start = chunkIndex * CHUNK_SIZE;
    const end = Math.min(start + CHUNK_SIZE, file.size);
    const chunk = file.slice(start, end);
    
    const formData = new FormData();
    formData.append('file', chunk);
    formData.append('uploadId', uploadId);
    formData.append('chunkIndex', String(chunkIndex));
    formData.append('totalChunks', String(totalChunks));
    
    await fetch('/api/media/upload-chunk', {
      method: 'POST',
      body: formData,
    });
    
    // 更新进度
    const progress = ((chunkIndex + 1) / totalChunks) * 100;
    console.log(`上传进度: ${progress.toFixed(0)}%`);
  }
  
  // 完成上传
  const response = await fetch('/api/media/complete-upload', {
    method: 'POST',
    body: JSON.stringify({ uploadId }),
  });
  
  const { url } = await response.json();
  return url;
}
```

### 4.2 并发上传控制

```typescript
class UploadQueue {
  private queue: Array<() => Promise<any>> = [];
  private running = 0;
  private maxConcurrent = 3; // 最多同时上传3个文件
  
  async add(task: () => Promise<any>): Promise<any> {
    return new Promise((resolve, reject) => {
      this.queue.push(async () => {
        try {
          const result = await task();
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
      
      this.process();
    });
  }
  
  private async process() {
    if (this.running >= this.maxConcurrent || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const task = this.queue.shift()!;
    
    try {
      await task();
    } finally {
      this.running--;
      this.process();
    }
  }
}

// 使用
const uploadQueue = new UploadQueue();

async function handleMultipleFiles(files: FileList) {
  const uploads = Array.from(files).map((file) =>
    uploadQueue.add(() => api.media.upload(file))
  );
  
  const results = await Promise.all(uploads);
  console.log('所有文件上传完成:', results);
}
```

---

## 五、WebSocket 优化

### 5.1 事件节流

对于频繁的事件（如"正在输入"），使用节流：

```typescript
import { throttle } from 'lodash-es';

const emitTypingThrottled = throttle((threadId: string, isTyping: boolean) => {
  if (connected) {
    // 发送正在输入事件
    api.threads.emitTyping(threadId, isTyping);
  }
}, 1000); // 每秒最多发送一次

// 使用
const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
  setInputMessage(e.target.value);
  
  // 节流发送"正在输入"事件
  emitTypingThrottled(threadId, e.target.value.length > 0);
};
```

### 5.2 WebSocket 重连策略

```typescript
class ReconnectingWebSocket {
  private ws: WebSocket | null = null;
  private url: string;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000; // 初始延迟1秒
  
  constructor(url: string) {
    this.url = url;
    this.connect();
  }
  
  private connect() {
    this.ws = new WebSocket(this.url);
    
    this.ws.onopen = () => {
      console.log('✅ WebSocket 已连接');
      this.reconnectAttempts = 0;
      this.reconnectDelay = 1000;
    };
    
    this.ws.onclose = () => {
      console.warn('⚠️ WebSocket 已断开');
      this.reconnect();
    };
    
    this.ws.onerror = (error) => {
      console.error('❌ WebSocket 错误:', error);
    };
  }
  
  private reconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('❌ WebSocket 重连失败，已达最大尝试次数');
      return;
    }
    
    this.reconnectAttempts++;
    console.log(`🔄 尝试重连 (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);
    
    setTimeout(() => {
      this.connect();
    }, this.reconnectDelay);
    
    // 指数退避
    this.reconnectDelay *= 2;
  }
  
  send(data: any) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(data));
    }
  }
}
```

---

## 六、性能监控

### 6.1 添加性能指标

```typescript
const PerformanceMonitor = {
  measureRender: (componentName: string) => {
    const start = performance.now();
    
    return () => {
      const end = performance.now();
      const duration = end - start;
      
      if (duration > 16) { // 超过一帧的时间（16ms）
        console.warn(`⚠️ ${componentName} 渲染耗时: ${duration.toFixed(2)}ms`);
      }
    };
  },
  
  measureAPI: async (apiName: string, apiCall: () => Promise<any>) => {
    const start = performance.now();
    
    try {
      const result = await apiCall();
      const end = performance.now();
      const duration = end - start;
      
      console.log(`📊 API ${apiName} 耗时: ${duration.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      console.error(`❌ API ${apiName} 失败:`, error);
      throw error;
    }
  },
};

// 使用
useEffect(() => {
  const endMeasure = PerformanceMonitor.measureRender('ChatPage');
  
  return endMeasure;
}, [messages]);

const loadThread = async () => {
  await PerformanceMonitor.measureAPI('getThread', () =>
    api.getThread(threadId)
  );
};
```

---

## 七、实施优先级

### 高优先级（必须实施）
1. ✅ 使用 `React.memo` 包装消息组件
2. ✅ 使用 `useCallback` 包装事件处理函数
3. ✅ 图片懒加载
4. ✅ 草稿防抖保存

### 中优先级（建议实施）
5. ✅ 消息列表缓存
6. ✅ 图片压缩
7. ✅ 并发上传控制
8. ✅ WebSocket 事件节流

### 低优先级（可选）
9. ⏸️ 虚拟滚动（仅在消息数>1000时）
10. ⏸️ 分片上传（仅在文件>10MB时）
11. ⏸️ IndexedDB 离线缓存

---

## 八、性能测试

### 测试场景
1. **大量消息渲染**: 加载1000条消息，测试滚动流畅度
2. **快速滚动**: 快速滚动消息列表，测试是否卡顿
3. **媒体文件加载**: 加载包含多个图片的会话，测试加载速度
4. **并发上传**: 同时上传多个文件，测试上传队列
5. **WebSocket 压力**: 频繁接收实时消息，测试更新性能

### 性能目标
- 消息渲染: <16ms/条
- 滚动帧率: >60fps
- API响应: <500ms
- 图片加载: <1s
- 内存占用: <200MB

---

**完成以上优化后，聊天系统将具备出色的性能表现！**

