# èŠå¤©ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–å®æ–½æŒ‡å—

## æ¦‚è¿°

æœ¬æŒ‡å—æä¾›äº†ä¸€ç³»åˆ—æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼Œä»¥ç¡®ä¿èŠå¤©ç³»ç»Ÿåœ¨å¤„ç†å¤§é‡æ¶ˆæ¯ã€åª’ä½“æ–‡ä»¶å’Œå®æ—¶æ›´æ–°æ—¶ä¿æŒæµç•…ã€‚

---

## ä¸€ã€æ¶ˆæ¯æ¸²æŸ“ä¼˜åŒ–

### 1.1 ä½¿ç”¨ React.memo å‡å°‘é‡æ¸²æŸ“

#### åˆ›å»º memo åŒ–çš„æ¶ˆæ¯ç»„ä»¶

**æ–‡ä»¶**: `web/components/chat/MessageBubble.tsx`ï¼ˆæ–°å»ºï¼‰

```typescript
'use client';

import React, { memo } from 'react';
import MediaPreview from '../media/MediaPreview';
import QuotedMessage from './QuotedMessage';
import MessageEditor from './MessageEditor';
import { WhatsAppColors } from '@/components/layout/WhatsAppLayout';

interface MessageBubbleProps {
  message: any;
  isOwn: boolean;
  isEditing: boolean;
  onContextMenu: (e: React.MouseEvent) => void;
  onEdit: (messageId: string, newText: string) => Promise<void>;
  onCancelEdit: () => void;
  onJumpToMessage?: (messageId: string) => void;
}

const MessageBubble = memo(({
  message,
  isOwn,
  isEditing,
  onContextMenu,
  onEdit,
  onCancelEdit,
  onJumpToMessage,
}: MessageBubbleProps) => {
  return (
    <div
      onContextMenu={onContextMenu}
      style={{
        maxWidth: '65%',
        backgroundColor: isOwn ? WhatsAppColors.ownMessage : WhatsAppColors.otherMessage,
        borderRadius: '8px',
        padding: '8px 12px',
        position: 'relative',
      }}
    >
      {/* å¼•ç”¨çš„æ¶ˆæ¯ */}
      {message.replyTo && (
        <div style={{ marginBottom: '8px' }}>
          <QuotedMessage
            message={message.replyTo}
            onJumpTo={onJumpToMessage}
            compact
          />
        </div>
      )}
      
      {/* åª’ä½“å†…å®¹ */}
      {message.mediaUrl && (
        <div style={{ marginBottom: message.text ? '8px' : 0 }}>
          <MediaPreview
            mediaUrl={message.mediaUrl}
            mediaType={message.mediaType}
            mediaMimeType={message.mediaMimeType}
            mediaFileName={message.mediaFileName}
            mediaSize={message.mediaSize}
            thumbnailUrl={message.thumbnailUrl}
            duration={message.duration}
          />
        </div>
      )}
      
      {/* ç¼–è¾‘æ¨¡å¼æˆ–æ¶ˆæ¯æ–‡æœ¬ */}
      {isEditing ? (
        <MessageEditor
          initialText={message.text || ''}
          onSave={(newText) => onEdit(message.id, newText)}
          onCancel={onCancelEdit}
        />
      ) : (
        <>
          {message.isDeleted ? (
            <div style={{ fontStyle: 'italic', color: '#8696a0' }}>
              æ­¤æ¶ˆæ¯å·²åˆ é™¤
            </div>
          ) : message.text && (
            <div style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-word' }}>
              {message.text}
            </div>
          )}
          
          {/* ç¿»è¯‘æ–‡æœ¬ */}
          {message.translatedText && !message.isDeleted && (
            <div
              style={{
                marginTop: '8px',
                paddingTop: '8px',
                borderTop: '1px solid rgba(0,0,0,0.1)',
                color: '#667781',
                fontSize: '13px',
              }}
            >
              <div style={{ fontSize: '11px', marginBottom: '4px' }}>ğŸŒ ç¿»è¯‘:</div>
              {message.translatedText}
            </div>
          )}
          
          {/* æ¶ˆæ¯å…ƒæ•°æ® */}
          <div
            style={{
              display: 'flex',
              justifyContent: 'flex-end',
              alignItems: 'center',
              gap: '4px',
              marginTop: '4px',
              fontSize: '11px',
              color: 'rgba(0,0,0,0.45)',
            }}
          >
            {message.isEdited && <span>å·²ç¼–è¾‘</span>}
            {message.isStarred && <span>â­</span>}
            <span>
              {new Date(message.createdAt).toLocaleTimeString('zh-CN', {
                hour: '2-digit',
                minute: '2-digit',
              })}
            </span>
            {isOwn && (
              <span>
                {message.readAt ? 'âœ“âœ“' : message.deliveredAt ? 'âœ“âœ“' : 'âœ“'}
              </span>
            )}
          </div>
        </>
      )}
    </div>
  );
}, (prevProps, nextProps) => {
  // è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°
  return (
    prevProps.message.id === nextProps.message.id &&
    prevProps.message.text === nextProps.message.text &&
    prevProps.message.isEdited === nextProps.message.isEdited &&
    prevProps.message.isDeleted === nextProps.message.isDeleted &&
    prevProps.message.isStarred === nextProps.message.isStarred &&
    prevProps.message.translatedText === nextProps.message.translatedText &&
    prevProps.message.deliveredAt === nextProps.message.deliveredAt &&
    prevProps.message.readAt === nextProps.message.readAt &&
    prevProps.isEditing === nextProps.isEditing
  );
});

MessageBubble.displayName = 'MessageBubble';

export default MessageBubble;
```

### 1.2 ä½¿ç”¨ useCallback åŒ…è£…äº‹ä»¶å¤„ç†å‡½æ•°

åœ¨èŠå¤©é¡µé¢ä¸­ï¼š

```typescript
const handleEditMessage = useCallback(async (messageId: string, newText: string) => {
  try {
    await api.messages.edit(messageId, newText);
    setEditingMessageId(null);
  } catch (error) {
    console.error('ç¼–è¾‘æ¶ˆæ¯å¤±è´¥:', error);
    throw error;
  }
}, []);

const handleCancelEdit = useCallback(() => {
  setEditingMessageId(null);
}, []);

const handleJumpToMessage = useCallback((messageId: string) => {
  // å®ç°è·³è½¬é€»è¾‘
  const element = document.getElementById(`message-${messageId}`);
  element?.scrollIntoView({ behavior: 'smooth', block: 'center' });
}, []);
```

### 1.3 æ¶ˆæ¯åˆ—è¡¨è™šæ‹ŸåŒ–ï¼ˆå¯é€‰ï¼Œé€‚ç”¨äº1000+æ¶ˆæ¯ï¼‰

å¦‚æœéœ€è¦å¤„ç†å¤§é‡æ¶ˆæ¯ï¼Œå¯ä»¥ä½¿ç”¨ `react-window`ï¼š

```bash
npm install react-window @types/react-window
```

**æ–‡ä»¶**: `web/components/chat/VirtualMessageList.tsx`

```typescript
'use client';

import React, { useRef, useEffect } from 'react';
import { FixedSizeList as List } from 'react-window';
import MessageBubble from './MessageBubble';

interface VirtualMessageListProps {
  messages: any[];
  height: number;
  onScroll?: (scrollTop: number) => void;
  editingMessageId: string | null;
  onEdit: (messageId: string, newText: string) => Promise<void>;
  onCancelEdit: () => void;
  onContextMenu: (e: React.MouseEvent, message: any) => void;
}

export default function VirtualMessageList({
  messages,
  height,
  onScroll,
  editingMessageId,
  onEdit,
  onCancelEdit,
  onContextMenu,
}: VirtualMessageListProps) {
  const listRef = useRef<any>(null);
  
  useEffect(() => {
    // æ»šåŠ¨åˆ°åº•éƒ¨
    if (listRef.current) {
      listRef.current.scrollToItem(messages.length - 1, 'end');
    }
  }, [messages.length]);
  
  const Row = ({ index, style }: any) => {
    const message = messages[index];
    const isOwn = message.direction === 'OUT' || message.fromMe;
    
    return (
      <div style={style}>
        <div
          id={`message-${message.id}`}
          style={{
            display: 'flex',
            justifyContent: isOwn ? 'flex-end' : 'flex-start',
            padding: '4px 12px',
          }}
        >
          <MessageBubble
            message={message}
            isOwn={isOwn}
            isEditing={editingMessageId === message.id}
            onContextMenu={(e) => onContextMenu(e, message)}
            onEdit={onEdit}
            onCancelEdit={onCancelEdit}
          />
        </div>
      </div>
    );
  };
  
  return (
    <List
      ref={listRef}
      height={height}
      itemCount={messages.length}
      itemSize={100} // ä¼°ç®—çš„æ¶ˆæ¯é«˜åº¦ï¼Œå¯ä»¥ä½¿ç”¨ dynamic item size
      width="100%"
      onScroll={({ scrollOffset }) => onScroll?.(scrollOffset)}
    >
      {Row}
    </List>
  );
}
```

---

## äºŒã€å›¾ç‰‡å’Œåª’ä½“ä¼˜åŒ–

### 2.1 å›¾ç‰‡æ‡’åŠ è½½

**æ–‡ä»¶**: `web/components/media/LazyImage.tsx`ï¼ˆæ–°å»ºï¼‰

```typescript
'use client';

import React, { useState, useEffect, useRef } from 'react';

interface LazyImageProps {
  src: string;
  alt?: string;
  thumbnail?: string;
  style?: React.CSSProperties;
  onClick?: () => void;
}

export default function LazyImage({ src, alt, thumbnail, style, onClick }: LazyImageProps) {
  const [loaded, setLoaded] = useState(false);
  const [inView, setInView] = useState(false);
  const imgRef = useRef<HTMLDivElement>(null);
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setInView(true);
          observer.disconnect();
        }
      },
      { rootMargin: '50px' } // æå‰50pxå¼€å§‹åŠ è½½
    );
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => observer.disconnect();
  }, []);
  
  return (
    <div ref={imgRef} style={{ position: 'relative', ...style }} onClick={onClick}>
      {/* ç¼©ç•¥å›¾æˆ–å ä½ç¬¦ */}
      {!loaded && (
        <div
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: '#f0f2f5',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}
        >
          {thumbnail ? (
            <img src={thumbnail} alt={alt} style={{ filter: 'blur(10px)', width: '100%', height: '100%' }} />
          ) : (
            <span>åŠ è½½ä¸­...</span>
          )}
        </div>
      )}
      
      {/* å®é™…å›¾ç‰‡ */}
      {inView && (
        <img
          src={src}
          alt={alt}
          onLoad={() => setLoaded(true)}
          style={{
            width: '100%',
            display: loaded ? 'block' : 'none',
          }}
        />
      )}
    </div>
  );
}
```

### 2.2 å›¾ç‰‡å‹ç¼©ï¼ˆä¸Šä¼ å‰ï¼‰

åœ¨ `MediaUploader` ç»„ä»¶ä¸­æ·»åŠ å›¾ç‰‡å‹ç¼©ï¼š

```typescript
// å®‰è£… browser-image-compression
// npm install browser-image-compression

import imageCompression from 'browser-image-compression';

const compressImage = async (file: File): Promise<File> => {
  const options = {
    maxSizeMB: 1, // æœ€å¤§1MB
    maxWidthOrHeight: 1920, // æœ€å¤§å®½åº¦æˆ–é«˜åº¦
    useWebWorker: true, // ä½¿ç”¨Web Workeræå‡æ€§èƒ½
  };
  
  try {
    const compressedFile = await imageCompression(file, options);
    console.log(`å‹ç¼©å‰: ${(file.size / 1024 / 1024).toFixed(2)}MB`);
    console.log(`å‹ç¼©å: ${(compressedFile.size / 1024 / 1024).toFixed(2)}MB`);
    return compressedFile;
  } catch (error) {
    console.error('å›¾ç‰‡å‹ç¼©å¤±è´¥:', error);
    return file; // å‹ç¼©å¤±è´¥åˆ™è¿”å›åŸæ–‡ä»¶
  }
};

// åœ¨ä¸Šä¼ å‰è°ƒç”¨
const handleFileSelect = async (files: FileList | null) => {
  if (!files || files.length === 0) return;
  
  let file = files[0];
  
  // å¦‚æœæ˜¯å›¾ç‰‡ï¼Œè¿›è¡Œå‹ç¼©
  if (file.type.startsWith('image/')) {
    file = await compressImage(file);
  }
  
  // ç»§ç»­ä¸Šä¼ ...
};
```

---

## ä¸‰ã€ç¼“å­˜ç­–ç•¥

### 3.1 æ¶ˆæ¯åˆ—è¡¨ç¼“å­˜

ä½¿ç”¨ `localStorage` æˆ– `IndexedDB` ç¼“å­˜æ¶ˆæ¯ï¼š

```typescript
// ç¼“å­˜å·¥å…·ç±»
class MessageCache {
  private static CACHE_KEY = 'whatsapp_messages_cache';
  private static CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24å°æ—¶
  
  static save(threadId: string, messages: any[]) {
    try {
      const cache = {
        threadId,
        messages,
        timestamp: Date.now(),
      };
      localStorage.setItem(`${this.CACHE_KEY}_${threadId}`, JSON.stringify(cache));
    } catch (error) {
      console.error('ä¿å­˜ç¼“å­˜å¤±è´¥:', error);
    }
  }
  
  static load(threadId: string): any[] | null {
    try {
      const cached = localStorage.getItem(`${this.CACHE_KEY}_${threadId}`);
      if (!cached) return null;
      
      const cache = JSON.parse(cached);
      
      // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
      if (Date.now() - cache.timestamp > this.CACHE_EXPIRY) {
        this.clear(threadId);
        return null;
      }
      
      return cache.messages;
    } catch (error) {
      console.error('åŠ è½½ç¼“å­˜å¤±è´¥:', error);
      return null;
    }
  }
  
  static clear(threadId: string) {
    localStorage.removeItem(`${this.CACHE_KEY}_${threadId}`);
  }
  
  static clearAll() {
    const keys = Object.keys(localStorage);
    keys.forEach((key) => {
      if (key.startsWith(this.CACHE_KEY)) {
        localStorage.removeItem(key);
      }
    });
  }
}

// åœ¨èŠå¤©é¡µé¢ä¸­ä½¿ç”¨
const loadThread = async () => {
  // å…ˆå°è¯•ä»ç¼“å­˜åŠ è½½
  const cachedMessages = MessageCache.load(threadId);
  if (cachedMessages) {
    setMessages(cachedMessages);
    setLoading(false);
  }
  
  // ç„¶åä»æœåŠ¡å™¨åŠ è½½æœ€æ–°æ•°æ®
  try {
    const data = await api.getThread(threadId);
    setMessages(data.messages);
    
    // æ›´æ–°ç¼“å­˜
    MessageCache.save(threadId, data.messages);
  } catch (error) {
    console.error('åŠ è½½ä¼šè¯å¤±è´¥:', error);
  } finally {
    setLoading(false);
  }
};
```

### 3.2 åª’ä½“æ–‡ä»¶ URL ç¼“å­˜

```typescript
class MediaUrlCache {
  private static cache = new Map<string, string>();
  
  static set(mediaId: string, url: string) {
    this.cache.set(mediaId, url);
  }
  
  static get(mediaId: string): string | undefined {
    return this.cache.get(mediaId);
  }
  
  static has(mediaId: string): boolean {
    return this.cache.has(mediaId);
  }
  
  static clear() {
    this.cache.clear();
  }
}

// ä½¿ç”¨
const getMediaUrl = async (mediaId: string): Promise<string> => {
  // å…ˆæ£€æŸ¥ç¼“å­˜
  if (MediaUrlCache.has(mediaId)) {
    return MediaUrlCache.get(mediaId)!;
  }
  
  // ä»APIè·å–
  const url = await api.media.getUrl(mediaId);
  
  // ç¼“å­˜URL
  MediaUrlCache.set(mediaId, url);
  
  return url;
};
```

### 3.3 è‰ç¨¿æœ¬åœ°å­˜å‚¨ä¼˜åŒ–

ä½¿ç”¨é˜²æŠ–æ¥å‡å°‘å­˜å‚¨æ“ä½œï¼š

```typescript
import { debounce } from 'lodash-es'; // æˆ–è‡ªå·±å®ç°

const saveDraftDebounced = debounce(async (threadId: string, draft: string) => {
  try {
    await api.threads.saveDraft(threadId, draft);
    console.log('ğŸ’¾ è‰ç¨¿å·²ä¿å­˜');
  } catch (error) {
    console.error('ä¿å­˜è‰ç¨¿å¤±è´¥:', error);
  }
}, 1000); // 1ç§’é˜²æŠ–

// ä½¿ç”¨
useEffect(() => {
  if (threadId && inputMessage) {
    saveDraftDebounced(threadId, inputMessage);
  }
}, [inputMessage, threadId]);
```

---

## å››ã€ä¸Šä¼ ä¼˜åŒ–

### 4.1 å¤§æ–‡ä»¶åˆ†ç‰‡ä¸Šä¼ 

```typescript
const CHUNK_SIZE = 1024 * 1024; // 1MB per chunk

async function uploadFileInChunks(file: File): Promise<string> {
  const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
  const uploadId = generateUniqueId();
  
  for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
    const start = chunkIndex * CHUNK_SIZE;
    const end = Math.min(start + CHUNK_SIZE, file.size);
    const chunk = file.slice(start, end);
    
    const formData = new FormData();
    formData.append('file', chunk);
    formData.append('uploadId', uploadId);
    formData.append('chunkIndex', String(chunkIndex));
    formData.append('totalChunks', String(totalChunks));
    
    await fetch('/api/media/upload-chunk', {
      method: 'POST',
      body: formData,
    });
    
    // æ›´æ–°è¿›åº¦
    const progress = ((chunkIndex + 1) / totalChunks) * 100;
    console.log(`ä¸Šä¼ è¿›åº¦: ${progress.toFixed(0)}%`);
  }
  
  // å®Œæˆä¸Šä¼ 
  const response = await fetch('/api/media/complete-upload', {
    method: 'POST',
    body: JSON.stringify({ uploadId }),
  });
  
  const { url } = await response.json();
  return url;
}
```

### 4.2 å¹¶å‘ä¸Šä¼ æ§åˆ¶

```typescript
class UploadQueue {
  private queue: Array<() => Promise<any>> = [];
  private running = 0;
  private maxConcurrent = 3; // æœ€å¤šåŒæ—¶ä¸Šä¼ 3ä¸ªæ–‡ä»¶
  
  async add(task: () => Promise<any>): Promise<any> {
    return new Promise((resolve, reject) => {
      this.queue.push(async () => {
        try {
          const result = await task();
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
      
      this.process();
    });
  }
  
  private async process() {
    if (this.running >= this.maxConcurrent || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const task = this.queue.shift()!;
    
    try {
      await task();
    } finally {
      this.running--;
      this.process();
    }
  }
}

// ä½¿ç”¨
const uploadQueue = new UploadQueue();

async function handleMultipleFiles(files: FileList) {
  const uploads = Array.from(files).map((file) =>
    uploadQueue.add(() => api.media.upload(file))
  );
  
  const results = await Promise.all(uploads);
  console.log('æ‰€æœ‰æ–‡ä»¶ä¸Šä¼ å®Œæˆ:', results);
}
```

---

## äº”ã€WebSocket ä¼˜åŒ–

### 5.1 äº‹ä»¶èŠ‚æµ

å¯¹äºé¢‘ç¹çš„äº‹ä»¶ï¼ˆå¦‚"æ­£åœ¨è¾“å…¥"ï¼‰ï¼Œä½¿ç”¨èŠ‚æµï¼š

```typescript
import { throttle } from 'lodash-es';

const emitTypingThrottled = throttle((threadId: string, isTyping: boolean) => {
  if (connected) {
    // å‘é€æ­£åœ¨è¾“å…¥äº‹ä»¶
    api.threads.emitTyping(threadId, isTyping);
  }
}, 1000); // æ¯ç§’æœ€å¤šå‘é€ä¸€æ¬¡

// ä½¿ç”¨
const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
  setInputMessage(e.target.value);
  
  // èŠ‚æµå‘é€"æ­£åœ¨è¾“å…¥"äº‹ä»¶
  emitTypingThrottled(threadId, e.target.value.length > 0);
};
```

### 5.2 WebSocket é‡è¿ç­–ç•¥

```typescript
class ReconnectingWebSocket {
  private ws: WebSocket | null = null;
  private url: string;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000; // åˆå§‹å»¶è¿Ÿ1ç§’
  
  constructor(url: string) {
    this.url = url;
    this.connect();
  }
  
  private connect() {
    this.ws = new WebSocket(this.url);
    
    this.ws.onopen = () => {
      console.log('âœ… WebSocket å·²è¿æ¥');
      this.reconnectAttempts = 0;
      this.reconnectDelay = 1000;
    };
    
    this.ws.onclose = () => {
      console.warn('âš ï¸ WebSocket å·²æ–­å¼€');
      this.reconnect();
    };
    
    this.ws.onerror = (error) => {
      console.error('âŒ WebSocket é”™è¯¯:', error);
    };
  }
  
  private reconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('âŒ WebSocket é‡è¿å¤±è´¥ï¼Œå·²è¾¾æœ€å¤§å°è¯•æ¬¡æ•°');
      return;
    }
    
    this.reconnectAttempts++;
    console.log(`ğŸ”„ å°è¯•é‡è¿ (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);
    
    setTimeout(() => {
      this.connect();
    }, this.reconnectDelay);
    
    // æŒ‡æ•°é€€é¿
    this.reconnectDelay *= 2;
  }
  
  send(data: any) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(data));
    }
  }
}
```

---

## å…­ã€æ€§èƒ½ç›‘æ§

### 6.1 æ·»åŠ æ€§èƒ½æŒ‡æ ‡

```typescript
const PerformanceMonitor = {
  measureRender: (componentName: string) => {
    const start = performance.now();
    
    return () => {
      const end = performance.now();
      const duration = end - start;
      
      if (duration > 16) { // è¶…è¿‡ä¸€å¸§çš„æ—¶é—´ï¼ˆ16msï¼‰
        console.warn(`âš ï¸ ${componentName} æ¸²æŸ“è€—æ—¶: ${duration.toFixed(2)}ms`);
      }
    };
  },
  
  measureAPI: async (apiName: string, apiCall: () => Promise<any>) => {
    const start = performance.now();
    
    try {
      const result = await apiCall();
      const end = performance.now();
      const duration = end - start;
      
      console.log(`ğŸ“Š API ${apiName} è€—æ—¶: ${duration.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      console.error(`âŒ API ${apiName} å¤±è´¥:`, error);
      throw error;
    }
  },
};

// ä½¿ç”¨
useEffect(() => {
  const endMeasure = PerformanceMonitor.measureRender('ChatPage');
  
  return endMeasure;
}, [messages]);

const loadThread = async () => {
  await PerformanceMonitor.measureAPI('getThread', () =>
    api.getThread(threadId)
  );
};
```

---

## ä¸ƒã€å®æ–½ä¼˜å…ˆçº§

### é«˜ä¼˜å…ˆçº§ï¼ˆå¿…é¡»å®æ–½ï¼‰
1. âœ… ä½¿ç”¨ `React.memo` åŒ…è£…æ¶ˆæ¯ç»„ä»¶
2. âœ… ä½¿ç”¨ `useCallback` åŒ…è£…äº‹ä»¶å¤„ç†å‡½æ•°
3. âœ… å›¾ç‰‡æ‡’åŠ è½½
4. âœ… è‰ç¨¿é˜²æŠ–ä¿å­˜

### ä¸­ä¼˜å…ˆçº§ï¼ˆå»ºè®®å®æ–½ï¼‰
5. âœ… æ¶ˆæ¯åˆ—è¡¨ç¼“å­˜
6. âœ… å›¾ç‰‡å‹ç¼©
7. âœ… å¹¶å‘ä¸Šä¼ æ§åˆ¶
8. âœ… WebSocket äº‹ä»¶èŠ‚æµ

### ä½ä¼˜å…ˆçº§ï¼ˆå¯é€‰ï¼‰
9. â¸ï¸ è™šæ‹Ÿæ»šåŠ¨ï¼ˆä»…åœ¨æ¶ˆæ¯æ•°>1000æ—¶ï¼‰
10. â¸ï¸ åˆ†ç‰‡ä¸Šä¼ ï¼ˆä»…åœ¨æ–‡ä»¶>10MBæ—¶ï¼‰
11. â¸ï¸ IndexedDB ç¦»çº¿ç¼“å­˜

---

## å…«ã€æ€§èƒ½æµ‹è¯•

### æµ‹è¯•åœºæ™¯
1. **å¤§é‡æ¶ˆæ¯æ¸²æŸ“**: åŠ è½½1000æ¡æ¶ˆæ¯ï¼Œæµ‹è¯•æ»šåŠ¨æµç•…åº¦
2. **å¿«é€Ÿæ»šåŠ¨**: å¿«é€Ÿæ»šåŠ¨æ¶ˆæ¯åˆ—è¡¨ï¼Œæµ‹è¯•æ˜¯å¦å¡é¡¿
3. **åª’ä½“æ–‡ä»¶åŠ è½½**: åŠ è½½åŒ…å«å¤šä¸ªå›¾ç‰‡çš„ä¼šè¯ï¼Œæµ‹è¯•åŠ è½½é€Ÿåº¦
4. **å¹¶å‘ä¸Šä¼ **: åŒæ—¶ä¸Šä¼ å¤šä¸ªæ–‡ä»¶ï¼Œæµ‹è¯•ä¸Šä¼ é˜Ÿåˆ—
5. **WebSocket å‹åŠ›**: é¢‘ç¹æ¥æ”¶å®æ—¶æ¶ˆæ¯ï¼Œæµ‹è¯•æ›´æ–°æ€§èƒ½

### æ€§èƒ½ç›®æ ‡
- æ¶ˆæ¯æ¸²æŸ“: <16ms/æ¡
- æ»šåŠ¨å¸§ç‡: >60fps
- APIå“åº”: <500ms
- å›¾ç‰‡åŠ è½½: <1s
- å†…å­˜å ç”¨: <200MB

---

**å®Œæˆä»¥ä¸Šä¼˜åŒ–åï¼ŒèŠå¤©ç³»ç»Ÿå°†å…·å¤‡å‡ºè‰²çš„æ€§èƒ½è¡¨ç°ï¼**

