# 聊天页面集成 - 代码补丁

本文件包含所有需要添加到 `web/app/chat/[id]/page.tsx` 的代码片段，按步骤分解。

---

## 步骤 1: 添加新组件导入

在文件顶部的导入区域（第9行后）添加：

```typescript
// 新增：媒体组件
import MediaPreview from '@/components/media/MediaPreview';
import MediaUploader from '@/components/media/MediaUploader';

// 新增：消息操作组件
import QuotedMessage from '@/components/chat/QuotedMessage';
import MessageContextMenu, { getMessageMenuItems } from '@/components/chat/MessageContextMenu';
import MessageEditor from '@/components/chat/MessageEditor';
import ForwardDialog from '@/components/chat/ForwardDialog';

// 新增：聊天辅助组件
import MessageSearch from '@/components/chat/MessageSearch';
import ThreadLabels from '@/components/chat/ThreadLabels';
```

---

## 步骤 2: 添加新的状态变量

在 `ChatPage` 组件内部，现有状态声明后添加：

```typescript
// 在现有状态后添加

// 新增：消息操作相关状态
const [replyToMessage, setReplyToMessage] = useState<any | null>(null);
const [editingMessageId, setEditingMessageId] = useState<string | null>(null);

// 新增：对话框状态
const [showForwardDialog, setShowForwardDialog] = useState(false);
const [forwardMessage, setForwardMessage] = useState<any | null>(null);
const [showMediaUploader, setShowMediaUploader] = useState(false);

// 新增：UI 状态
const [showSearch, setShowSearch] = useState(false);

// 新增：右键菜单状态
const [contextMenu, setContextMenu] = useState<{
  show: boolean;
  x: number;
  y: number;
  message: any;
} | null>(null);

// 新增：分页加载状态
const [hasMoreMessages, setHasMoreMessages] = useState(true);
const [loadingMoreMessages, setLoadingMoreMessages] = useState(false);

// 新增：草稿自动保存定时器
const draftSaveTimerRef = useRef<NodeJS.Timeout>();
```

---

## 步骤 3: 添加草稿自动保存

在 `useEffect` 区域添加：

```typescript
// 草稿自动保存
useEffect(() => {
  if (!threadId || !inputMessage) return;
  
  // 清除之前的定时器
  if (draftSaveTimerRef.current) {
    clearTimeout(draftSaveTimerRef.current);
  }
  
  // 延迟保存草稿（防抖）
  draftSaveTimerRef.current = setTimeout(async () => {
    try {
      await api.threads.saveDraft(threadId, inputMessage);
      console.log('💾 草稿已保存');
    } catch (error) {
      console.error('保存草稿失败:', error);
    }
  }, 1000);
  
  return () => {
    if (draftSaveTimerRef.current) {
      clearTimeout(draftSaveTimerRef.current);
    }
  };
}, [inputMessage, threadId]);
```

---

## 步骤 4: 修改 `loadThread` 函数

在现有的 `loadThread` 函数中添加加载草稿的逻辑：

```typescript
const loadThread = async () => {
  // ... 现有代码保持不变 ...
  
  // 在设置 messages 之后添加：
  
  // 新增：加载草稿
  try {
    const draft = await api.threads.getDraft(threadId);
    if (draft?.draft) {
      setInputMessage(draft.draft);
    }
  } catch (error) {
    console.error('加载草稿失败:', error);
  }
  
  // ... 其余代码保持不变 ...
};
```

---

## 步骤 5: 添加分页加载函数

在组件内添加新函数：

```typescript
// 加载更多历史消息
const loadMoreMessages = async () => {
  if (!threadId || loadingMoreMessages || !hasMoreMessages) return;
  
  try {
    setLoadingMoreMessages(true);
    
    // 获取最早的消息时间
    const oldestMessage = messages[0];
    const before = oldestMessage?.createdAt;
    
    const data = await api.threads.getMessages(threadId, 50, before);
    
    if (data.messages && data.messages.length > 0) {
      // 保存当前滚动位置
      const container = messageContainerRef.current;
      const oldScrollHeight = container?.scrollHeight || 0;
      
      // 添加历史消息到列表顶部
      setMessages((prev) => [...data.messages, ...prev]);
      setHasMoreMessages(data.hasMore || false);
      
      // 恢复滚动位置
      setTimeout(() => {
        if (container) {
          const newScrollHeight = container.scrollHeight;
          container.scrollTop = newScrollHeight - oldScrollHeight;
        }
      }, 0);
    } else {
      setHasMoreMessages(false);
    }
  } catch (error) {
    console.error('加载历史消息失败:', error);
  } finally {
    setLoadingMoreMessages(false);
  }
};

// 监听滚动事件
const handleScroll = useCallback(() => {
  const container = messageContainerRef.current;
  if (!container) return;
  
  // 滚动到顶部时加载更多
  if (container.scrollTop < 100) {
    loadMoreMessages();
  }
}, [loadingMoreMessages, hasMoreMessages]);

// 添加滚动监听
useEffect(() => {
  const container = messageContainerRef.current;
  if (!container) return;
  
  container.addEventListener('scroll', handleScroll);
  return () => container.removeEventListener('scroll', handleScroll);
}, [handleScroll]);
```

---

## 步骤 6: 添加消息操作函数

```typescript
// 右键菜单处理
const handleMessageContextMenu = (e: React.MouseEvent, message: any) => {
  e.preventDefault();
  setContextMenu({
    show: true,
    x: e.clientX,
    y: e.clientY,
    message,
  });
};

// 引用消息
const handleReplyMessage = (message: any) => {
  setReplyToMessage(message);
  setContextMenu(null);
  inputRef.current?.focus();
};

// 编辑消息
const handleEditMessage = async (messageId: string, newText: string) => {
  try {
    await api.messages.edit(messageId, newText);
    setEditingMessageId(null);
    console.log('✅ 消息已编辑');
  } catch (error) {
    console.error('编辑消息失败:', error);
    throw error;
  }
};

// 删除消息
const handleDeleteMessage = async (message: any) => {
  if (!confirm('确定要删除这条消息吗？')) return;
  
  try {
    await api.messages.delete(message.id);
    setContextMenu(null);
    console.log('✅ 消息已删除');
  } catch (error) {
    console.error('删除消息失败:', error);
    alert('删除失败，请重试');
  }
};

// 转发消息
const handleForwardMessage = async (threadIds: string[]) => {
  if (!forwardMessage) return;
  
  try {
    await api.messages.forward(forwardMessage.id, threadIds);
    setShowForwardDialog(false);
    setForwardMessage(null);
    setContextMenu(null);
    console.log(`✅ 消息已转发到 ${threadIds.length} 个会话`);
    alert(`消息已转发到 ${threadIds.length} 个会话`);
  } catch (error) {
    console.error('转发消息失败:', error);
    throw error;
  }
};

// 标记星标
const handleStarMessage = async (message: any) => {
  try {
    await api.messages.star(message.id, !message.isStarred);
    setContextMenu(null);
    
    setMessages((prev) =>
      prev.map((msg) =>
        msg.id === message.id
          ? { ...msg, isStarred: !msg.isStarred }
          : msg
      )
    );
  } catch (error) {
    console.error('标记消息失败:', error);
    alert('操作失败，请重试');
  }
};

// 复制消息
const handleCopyMessage = (message: any) => {
  if (message.text) {
    navigator.clipboard.writeText(message.text);
    alert('已复制到剪贴板');
    setContextMenu(null);
  }
};

// 媒体上传
const handleMediaUpload = async (result: any) => {
  if (!threadId) return;
  
  try {
    const messageData = {
      threadId,
      text: result.fileName || '',
      mediaUrl: result.url,
      mediaType: result.type,
      mediaMimeType: result.mimeType,
      mediaSize: result.size,
      mediaFileName: result.fileName,
      thumbnailUrl: result.thumbnailUrl,
    };
    
    await api.sendMessage(threadId, '', messageData);
    setShowMediaUploader(false);
    console.log('✅ 媒体文件已发送');
  } catch (error) {
    console.error('发送媒体消息失败:', error);
    alert('发送失败，请重试');
  }
};
```

---

## 步骤 7: 修改 `handleSendMessage` 函数

更新发送消息函数以支持引用回复：

```typescript
const handleSendMessage = async () => {
  if (!inputMessage.trim() || sending || !threadId) return;
  
  try {
    setSending(true);
    
    // 新增：如果有引用消息，使用引用API
    if (replyToMessage) {
      await api.messages.reply(threadId, inputMessage.trim(), replyToMessage.id);
    } else {
      await api.sendMessage(threadId, inputMessage.trim());
    }
    
    // 清空输入和引用
    setInputMessage('');
    setReplyToMessage(null);  // 新增
    setSending(false);
    
    // 新增：清除草稿
    api.threads.saveDraft(threadId, '').catch(console.error);
    
    inputRef.current?.focus();
  } catch (error: any) {
    console.error('发送消息失败:', error);
    alert('发送失败: ' + error.message);
    setSending(false);
  }
};
```

---

## 步骤 8: 更新 WebSocket 事件处理

在现有的 WebSocket useEffect 中添加新事件：

```typescript
useEffect(() => {
  if (!lastMessage) return;
  
  const { type, data } = lastMessage;
  
  switch (type) {
    case 'new_message':
      handleNewMessage(data);
      break;
      
    // 新增事件处理
    case 'message_edited':
      setMessages((prev) =>
        prev.map((msg) =>
          msg.id === data.messageId
            ? { ...msg, text: data.text, isEdited: true, editedAt: data.editedAt }
            : msg
        )
      );
      break;
      
    case 'message_deleted':
      setMessages((prev) =>
        prev.map((msg) =>
          msg.id === data.messageId
            ? { ...msg, isDeleted: true, deletedAt: data.deletedAt }
            : msg
        )
      );
      break;
      
    case 'message_starred':
      setMessages((prev) =>
        prev.map((msg) =>
          msg.id === data.messageId
            ? { ...msg, isStarred: data.isStarred, starredAt: data.starredAt }
            : msg
        )
      );
      break;
      
    case 'message_status':
      // 现有代码保持不变
      break;
  }
}, [lastMessage]);
```

---

## 步骤 9: 更新消息渲染（替换原有的消息渲染部分）

找到消息渲染的部分，更新为：

```typescript
{messages.map((message, index) => {
  const isOwn = message.direction === 'OUT' || message.fromMe;
  const isEditing = editingMessageId === message.id;
  
  return (
    <div
      key={message.id}
      ref={index === messages.length - 1 ? lastMessageRef : null}
      onContextMenu={(e) => handleMessageContextMenu(e, message)}
      style={{
        display: 'flex',
        justifyContent: isOwn ? 'flex-end' : 'flex-start',
        marginBottom: '8px',
        padding: '0 12px',
      }}
    >
      <div
        style={{
          maxWidth: '65%',
          backgroundColor: isOwn ? WhatsAppColors.ownMessage : WhatsAppColors.otherMessage,
          borderRadius: '8px',
          padding: '8px 12px',
        }}
      >
        {/* 引用的消息 */}
        {message.replyTo && (
          <div style={{ marginBottom: '8px' }}>
            <QuotedMessage
              message={message.replyTo}
              onJumpTo={(id) => console.log('跳转到:', id)}
              compact
            />
          </div>
        )}
        
        {/* 媒体内容 */}
        {message.mediaUrl && (
          <div style={{ marginBottom: message.text ? '8px' : 0 }}>
            <MediaPreview
              mediaUrl={message.mediaUrl}
              mediaType={message.mediaType}
              mediaMimeType={message.mediaMimeType}
              mediaFileName={message.mediaFileName}
              mediaSize={message.mediaSize}
              thumbnailUrl={message.thumbnailUrl}
              duration={message.duration}
            />
          </div>
        )}
        
        {/* 编辑模式或消息文本 */}
        {isEditing ? (
          <MessageEditor
            initialText={message.text || ''}
            onSave={(newText) => handleEditMessage(message.id, newText)}
            onCancel={() => setEditingMessageId(null)}
          />
        ) : (
          <>
            {message.isDeleted ? (
              <div style={{ fontStyle: 'italic', color: '#8696a0' }}>
                此消息已删除
              </div>
            ) : message.text && (
              <div style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-word' }}>
                {message.text}
              </div>
            )}
            
            {/* 翻译文本（如果有） */}
            {message.translatedText && !message.isDeleted && (
              <div
                style={{
                  marginTop: '8px',
                  paddingTop: '8px',
                  borderTop: '1px solid rgba(0,0,0,0.1)',
                  color: '#667781',
                  fontSize: '13px',
                }}
              >
                <div style={{ fontSize: '11px', marginBottom: '4px' }}>🌐 翻译:</div>
                {message.translatedText}
              </div>
            )}
            
            {/* 消息元数据 */}
            <div
              style={{
                display: 'flex',
                justifyContent: 'flex-end',
                alignItems: 'center',
                gap: '4px',
                marginTop: '4px',
                fontSize: '11px',
                color: 'rgba(0,0,0,0.45)',
              }}
            >
              {message.isEdited && <span>已编辑</span>}
              {message.isStarred && <span>⭐</span>}
              <span>
                {new Date(message.createdAt).toLocaleTimeString('zh-CN', {
                  hour: '2-digit',
                  minute: '2-digit',
                })}
              </span>
              {isOwn && (
                <span>
                  {message.readAt ? '✓✓' : message.deliveredAt ? '✓✓' : '✓'}
                </span>
              )}
            </div>
          </>
        )}
      </div>
    </div>
  );
})}
```

---

## 步骤 10: 更新聊天头部（在现有聊天头部中添加）

在聊天头部添加搜索按钮：

```typescript
{/* 在现有聊天头部的右侧添加 */}
<div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
  {/* 搜索按钮 */}
  <button
    onClick={() => setShowSearch(!showSearch)}
    style={{
      width: '40px',
      height: '40px',
      borderRadius: '50%',
      border: 'none',
      backgroundColor: showSearch ? WhatsAppColors.selected : 'transparent',
      cursor: 'pointer',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      fontSize: '20px',
    }}
    title="搜索消息"
  >
    🔍
  </button>
</div>
```

在聊天头部下方添加搜索组件：

```typescript
{/* 在聊天头部后添加 */}
{showSearch && (
  <MessageSearch
    threadId={threadId}
    onMessageClick={(messageId) => {
      console.log('跳转到消息:', messageId);
    }}
    onClose={() => setShowSearch(false)}
  />
)}
```

---

## 步骤 11: 更新输入区域

在输入区域的开头添加引用预览：

```typescript
<div style={styles.inputContainer}>
  {/* 引用消息预览 */}
  {replyToMessage && (
    <div style={{ padding: '8px 12px', backgroundColor: WhatsAppColors.background }}>
      <QuotedMessage
        message={replyToMessage}
        onCancel={() => setReplyToMessage(null)}
        compact
      />
    </div>
  )}
  
  {/* 现有的输入行 */}
  <div style={styles.inputRow}>
    {/* 添加附件按钮 */}
    <button
      onClick={() => setShowMediaUploader(true)}
      style={{
        width: '40px',
        height: '40px',
        borderRadius: '50%',
        border: 'none',
        backgroundColor: 'transparent',
        cursor: 'pointer',
        fontSize: '24px',
      }}
      title="附件"
    >
      📎
    </button>
    
    {/* 现有的输入框和其他按钮保持不变 */}
  </div>
</div>
```

---

## 步骤 12: 添加对话框组件（在 return 的最后）

```typescript
{/* 在 return 语句的最后，</WhatsAppLayout> 之前添加 */}

{/* 右键菜单 */}
{contextMenu?.show && (
  <MessageContextMenu
    x={contextMenu.x}
    y={contextMenu.y}
    items={getMessageMenuItems(contextMenu.message, {
      onReply: () => handleReplyMessage(contextMenu.message),
      onEdit: () => setEditingMessageId(contextMenu.message.id),
      onDelete: () => handleDeleteMessage(contextMenu.message),
      onForward: () => {
        setForwardMessage(contextMenu.message);
        setShowForwardDialog(true);
      },
      onStar: () => handleStarMessage(contextMenu.message),
      onCopy: () => handleCopyMessage(contextMenu.message),
    })}
    onClose={() => setContextMenu(null)}
  />
)}

{/* 转发对话框 */}
{showForwardDialog && forwardMessage && (
  <ForwardDialog
    message={forwardMessage}
    onForward={handleForwardMessage}
    onClose={() => {
      setShowForwardDialog(false);
      setForwardMessage(null);
    }}
  />
)}

{/* 媒体上传器 */}
{showMediaUploader && (
  <div
    style={{
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      zIndex: 9999,
    }}
    onClick={() => setShowMediaUploader(false)}
  >
    <div
      onClick={(e) => e.stopPropagation()}
      style={{
        backgroundColor: WhatsAppColors.panelBackground,
        borderRadius: '12px',
        padding: '24px',
        maxWidth: '500px',
        width: '90%',
      }}
    >
      <h3 style={{ marginBottom: '16px' }}>上传文件</h3>
      <MediaUploader
        onUploadComplete={handleMediaUpload}
        onUploadError={(error) => {
          console.error('上传失败:', error);
          alert('上传失败: ' + error.message);
        }}
      />
      <button
        onClick={() => setShowMediaUploader(false)}
        style={{
          marginTop: '16px',
          padding: '8px 16px',
          width: '100%',
          border: 'none',
          borderRadius: '6px',
          backgroundColor: WhatsAppColors.border,
          cursor: 'pointer',
        }}
      >
        取消
      </button>
    </div>
  </div>
)}
```

---

## ✅ 集成完成检查清单

完成所有步骤后，检查：

- [ ] 所有新导入都已添加
- [ ] 所有新状态都已添加
- [ ] 草稿自动保存功能正常
- [ ] 分页加载功能正常
- [ ] 所有消息操作函数都已添加
- [ ] handleSendMessage 支持引用回复
- [ ] WebSocket 事件处理已更新
- [ ] 消息渲染包含所有新功能
- [ ] 聊天头部有搜索按钮
- [ ] 输入区域有引用预览和附件按钮
- [ ] 所有对话框组件都已添加

---

## 🐛 常见问题

### Q: 导入错误
A: 确保所有组件文件都在正确的位置

### Q: TypeScript 类型错误
A: 确保 `web/lib/api.ts` 已更新

### Q: 运行时错误
A: 检查浏览器控制台，逐步排查

---

**完成后，所有新功能将在聊天页面中可用！**

